#!/usr/bin/env python
# -*- coding:Utf-8 -*-

"""Provides the Ant class for the ants module.
"""

import config
import uuid
import threading
import multiprocessing
import random
import time
import logging
import utils

__author__ = "Doug Le Tough"
__copyright__ = "Copyright 2017, Doug Le Tough"
__credits__ = ["Doug Le Tough",]
__license__ = "WTFPL"
__version__ = "1.0.0"
__maintainer__ = "Doug Le Tough"
__email__ = "doug.letough@free.fr"
__status__ = "Testing"

###################################################################################################################
# Ant
###################################################################################################################

class Ant(threading.Thread):
  """ The Ant object is a self living virtual creature that tries to simulate
  some ant's basic behaviour.
  The Ant object runs its own thread.
  """
  def __init__(self, playground, display_q, position, farm_id):
    """
    - playground: The Playground in which the Ant lives
    - display_q: The FIFO queue in wich data are sent to the Display object
    - position: A tuple seen as initial position (x, y)
    - farm_id: The Farm ID to which the Ant belongs
    """
    threading.Thread.__init__(self)
    self.color = config.ANT_HUNTING_COLOR
    self.outline_color = config.ANT_NEUTRAL_OUTLINE_COLOR
    self.ID = str(uuid.uuid4())
    self.playground = playground
    self.position = position
    self.new_position = position
    self.direction = None
    self.display_q = display_q
    self.farm_id = farm_id
    self.life = config.ANT_MAX_LIFE
    self.waiting = False
    self.history = []
    self.togo = []
    self.food = 0
    self.last_hail = None
    self.data = {'type': 'Ant %s' % (self.ID)}

  def __str__(self):
    """ Returns a string representation of the Ant. """
    return str(self.to_dict())

  def to_dict(self):
    """ Returns a dict representation of the Ant object. This representation is
    used by the Display workers to display the Ant.
    """
    return {'type': 'ant',
            'ID': self.ID,
            'old_position': self.position,
            'new_position': self.new_position,
            'radius': config.ANT_RADIUS,
            'color': self.color,
            'outline': self.outline_color
           }

  def set_colors(self):
    """ Adjust the Ant colors depending on the Ant status.
    """
    if self.food > 0:
      self.color = config.ANT_HOMING_COLOR
      self.outline_color = config.ANT_LOST_OUTLINE_COLOR
      if self.is_busy():
        self.outline_color = config.ANT_BUSY_OUTLINE_COLOR
    else:
      self.color = config.ANT_HUNTING_COLOR
      self.outline_color = config.ANT_NEUTRAL_OUTLINE_COLOR
      if self.is_busy():
        self.outline_color = config.ANT_BUSY_OUTLINE_COLOR

  def walk(self):
    """ Set a new position.
    If Ant already has a path to go, then the next position is picked up from this path.
    Otherwise, a new position is randomly picked up. 
    """
    if self.is_busy():
      self.new_position = self.pop_new_position()
    else:
      self.new_position = self.set_new_position()
    self.display_q.put(self.to_dict())
    self.position = self.new_position
    
  def set_new_position(self):
    """ Set a new position from the actual position.
    A new position is randomly generated by adding -1, 0 or 1 to one of
    the actual position componant (x or y).
    If the new position is out of the playground then the position is
    adjusted. Thus an ant can not walk out of the play ground which is finite.
    """
    if not self.direction:
      self.direction = (utils.random_dir(), utils.random_dir())
    else:
      if not int(random.random() * 10) % 4:
        if int(random.random() * 2) % 2:
          self.direction = (utils.random_dir(), self.direction[1])
        else:
          self.direction = (self.direction[0], utils.random_dir())
    new_pos_x = self.position[0] + self.direction[0]
    new_pos_y = self.position[1] + self.direction[1]
    if new_pos_x > self.playground.width:
      new_pos_x = self.playground.width
    if new_pos_x < 0:
      new_pos_x = 0
    if new_pos_y > self.playground.height:
      new_pos_y = self.playground.height
    if new_pos_y < 0:
      new_pos_y = 0
    return (new_pos_x, new_pos_y)

  def pop_new_position(self):
    """ Pick the next position in the path to go.
    """
    return self.togo.pop(0)

  def record(self):
    """ Record the actual position in the Ant history.
    For each new record, the history is recreated in a way that the shortest path
    from the oldest position to the current position is retained.
    Still, the new shortest path will only use position wihin the history.
    The shortest path from within the history is rarely (who said never ?) the shortest path on the play ground.
    """
    # FIXME: utils.get_shortest_path()
    # Any better optimization algorithm out here ?
    self.history = utils.get_shortest_path(self.ID, self.history, self.position, config.ANT_RADIUS)

  def clean_history(self):
    """ Delete oldest position in history when history length is larger than <max_history>.
    See config.ANT_MAX_HISTORY
    """
    if len(self.history) > config.ANT_MAX_HISTORY:
      self.history.pop(0)

  def check_around(self):
    """ Process actions according to what is around the present position.
    Object around the present position are given bay the Playground.scan(position) method.
    """
    around = self.playground.scan(self.position)
    ants = around['ants']
    farms = around['farms']
    mines = around['mines']
    if len(farms) > 0:
      for farm in farms:
        self.store(farm)
    if len(mines) > 0:
      for mine in mines:
        self.mine(mine)
    if len(ants) > 0:
      for ant in ants:
        if ant.ID != self.ID:
          self.hail(ant)

  def hail(self, ant):
    """ Hails the given Ant.
    Whenever an Ant encounter an another, it hails it.
    Depending on the status of each the concerned Ants, some data are exchanged.
    An Ant can not hail a dead Ant.
    """
    todo = "\033[92mHail:\033[0m %s " % ant.ID
    ant.wait()
    # Fucking Hack: Compare a string representation of multiple boolean conditions
    history_table = ['0110', '0011', '0001']
    togo_table =['0111', '0010']
    truth = '%d%d%d%d' % (self.is_busy(), self.has_food(), ant.is_busy(), ant.has_food())
    if truth in history_table:
      todo += "033[92mUpdated:\033[0m Togo" 
      self.togo = [ant.position] + list(reversed(ant.history))
      self.pause(config.ANT_PAUSE_DELAY)
    elif truth in togo_table:
      todo += "033[92mUpdated:\033[0m History" 
      self.togo = [ant.position] + ant.togo[:]
      self.pause(config.ANT_PAUSE_DELAY)
    # /Fucking hack
    ant.restart()
    logging.warning(todo, extra=self.data)

  def store(self, farm):
    """ Stores the carried food to the given farm. """
    if farm.ID == self.farm_id and self.food > 0:
      food = self.food
      farm.store(self.food, self.ID)
      self.food = 0
      self.swap_histories()

  def mine(self, mine):
    """ Pick the maximum food amount from the given mine."""
    if self.food < config.ANT_MAX_FOOD:
      food = 0
      if mine.stock > 0:
        food = mine.stock
        self.swap_histories()
        if mine.stock >= config.ANT_MAX_FOOD - self.food:
          food = config.ANT_MAX_FOOD - self.food
      mine.pick(food, self.ID)
      self.food = food

  def swap_histories(self):
    """ Swap history and path to go.
    When an Ant find food, it needs to go back home.
    The partial or complete path to home is in its history so the history is reverted then given has a path to go.
    Once the path to go is set, the actual history is wiped out.
    Same process occurs when an Ant comes back to home with food, so it can go back to the Mine.
    
    """
    self.togo = list(reversed(self.history))
    self.history = [self.position]

  def in_range(self, position):
    """ Returns if wheter or not the given position is aside the Ant.
    - Position: A tuple seen as coordinates (x, y)"""
    pos_x, pos_y = position
    dx = abs(pos_x - self.position[0])
    dy = abs(pos_y - self.position[1])
    result = False
    if dx + dy <= config.ANT_RADIUS:
        result = True
    if dx > config.ANT_RADIUS:
        result = False
    if dy > config.ANT_RADIUS:
        result = False
    if pow(dx, 2) + pow(dy, 2) <= pow(config.ANT_RADIUS, 2):
        result = True
    else:
      result = False
    return result

  def is_busy(self):
    """ Returns wheter or not the Ant is busy.
    An Ant is busy when the length of its path to go is > 0.
    """
    return len(self.togo) > 0

  def is_alice(self):
    """ Rturns wether or not Ant <life> is > 0"""
    return self.life > 0

  def has_food(self):
    """ Returns whether or not the Ant carries food """
    return self.food > 0

  def wait(self):
    """ Wait until restart() is called."""
    logging.warning('\033[92mStatus:\033[0m Waiting', extra=self.data)
    self.waiting = True

  def restart(self):
    """ Restart after wait() """
    logging.warning('\033[92mStatus:\033[0m Restarted', extra=self.data)
    self.waiting = False

  def pause(self, delay):
    """ Wait time seconds """
    time.sleep(delay)

  def stop(self):
    """ Kill the Ant.
    this will exit the Ant thread. """
    self.wait()
    self.life = 0

  def run(self):
    """ The Ant thread main loop """
    while self.life > 0:
      while not self.waiting:
        self.check_around()
        self.set_colors()
        self.walk()
        self.record()
        self.clean_history()
        self.life -= 1
        if self.life == 0 and self.food > 0:
          self.food -= 1
          self.life += int(config.ANT_MAX_LIFE / 3)
        logging.warning('\033[92mPosition:\033[0m %s, \033[92mLife:\033[0m %d, \033[92mFood:\033[0m %d, \033[92mBusy:\033[0m %s, \033[92mHistory:\033[0m %d' % (str(self.position), self.life, self.food, self.is_busy(), len(self.history)), extra=self.data)
        time.sleep(config.ANT_TURN_SLEEP_DELAY)
      time.sleep(config.ANT_HAIL_WAIT_DELAY)
    self.outline_color = config.ANT_DEAD_OUTLINE_COLOR
    self.display_q.put(self.to_dict())
    logging.warning('\033[91mDied at:\033[0m %s, \033[95mHistory:\033[0m %d' % (str(self.position), len(self.history)), extra=self.data)
